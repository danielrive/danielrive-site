"use strict";(self.webpackChunkdanielrive_site=self.webpackChunkdanielrive_site||[]).push([[1181],{510:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>t,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var s=a(4848),o=a(8453);const r={slug:"containers-history",title:"Containers - entre historia y runtimes",authors:["danielrivera"],tags:["kubernetes"]},i=void 0,c={permalink:"/blog/containers-history",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-03-26-Containers-entre-historia-runtimes.md",source:"@site/blog/2023-03-26-Containers-entre-historia-runtimes.md",title:"Containers - entre historia y runtimes",description:"containers-crazy",date:"2023-03-26T00:00:00.000Z",tags:[{inline:!1,label:"Kubernetes",permalink:"/blog/tags/kubernetes",description:"Content related with Kubernetes"}],readingTime:8.96,hasTruncateMarker:!0,authors:[{name:"Daniel German Rivera",title:"Cloud Engineer",url:"https://github.com/danielrive",page:{permalink:"/blog/authors/danielrivera"},socials:{github:"https://github.com/danielrive",linkedin:"https://www.linkedin.com/in/danielrive/"},key:"danielrivera"}],frontMatter:{slug:"containers-history",title:"Containers - entre historia y runtimes",authors:["danielrivera"],tags:["kubernetes"]},unlisted:!1,prevItem:{title:"AWS Infrastructure Terraform and GitHub Actions",permalink:"/blog/github-actions"},nextItem:{title:"Enabling logs and alerting in AWS EKS cluster - CloudWatch Log Insights and Metric filters",permalink:"/blog/Log-Insights"}},t={authorsImageUrls:[void 0]},l=[{value:"Lo b\xe1sico",id:"lo-b\xe1sico",level:2},{value:"Linux namespaces",id:"linux-namespaces",level:3},{value:"cgroups",id:"cgroups",level:3},{value:"Un poco de historia",id:"un-poco-de-historia",level:3},{value:"La llegada de Docker",id:"la-llegada-de-docker",level:4},{value:"Definiendo un est\xe1ndar para containers",id:"definiendo-un-est\xe1ndar-para-containers",level:4},{value:"OCI Runtime spec",id:"oci-runtime-spec",level:4},{value:"OCI Image spec",id:"oci-image-spec",level:4},{value:"Container runtimes y Kubernetes",id:"container-runtimes-y-kubernetes",level:4},{value:"Container Images",id:"container-images",level:3},{value:"copiando images con skopeo",id:"copiando-images-con-skopeo",level:4}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/sox1n5tbcssth6p8eayl.png",alt:"containers-crazy"})}),"\n",(0,s.jsxs)(n.p,{children:["Estudiando kubernetes gast\xe9 un tiempo considerable intentando entender muchos conceptos, por ejemplo, por todo lado se habla de ",(0,s.jsx)(n.em,{children:"OCI compliant"}),", buscas ",(0,s.jsx)(n.em,{children:"OCI"})," y te lleva a ",(0,s.jsx)(n.em,{children:"runtime-spec"}),", buscas ",(0,s.jsx)(n.em,{children:"runtimes"})," y te lleva a ",(0,s.jsx)(n.em,{children:"containerd"}),", ",(0,s.jsx)(n.em,{children:"runc"}),", ",(0,s.jsx)(n.em,{children:"image-spec"}),", ",(0,s.jsx)(n.em,{children:"cgroups"}),", ",(0,s.jsx)(n.em,{children:"namespaces"}),", etc; puedes pasar d\xedas buscando, y mucho m\xe1s cuando eres del tipo de persona que quiere entender a fondo c\xf3mo funcionan las cosas."]}),"\n",(0,s.jsx)(n.p,{children:"Motivado por lo anterior, me decid\xed a escribir este post con la idea de compartir los conceptos que logr\xe9 adquirir y que me han servido para entender varias cosas del gran mundo de los containers, en algunas cosas no voy a tan bajo nivel ya que hay muchos conceptos que todav\xeda desconozco y puedo decir cosas equiviocadas."}),"\n",(0,s.jsx)(n.h2,{id:"lo-b\xe1sico",children:"Lo b\xe1sico"}),"\n",(0,s.jsx)(n.p,{children:"Iniciemos entendiendo un poco la idea detr\xe1s de los containers."}),"\n",(0,s.jsxs)(n.p,{children:["Containers tienen como objetivo crear un ambiente virtual ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.em,{children:"aislado"})})," el cual se pueda distribuir y desplegar f\xe1cilmente. Dentro del container pueden correr diferentes procesos los cuales deben estar aislados de otros corriendo en el host. El kernel de linux ofrece distintas funcionalidades que permiten la creaci\xf3n de estos ambientes. Hay dos componentes principales que quiz\xe1s son el core de todos los containers."]}),"\n",(0,s.jsx)(n.h3,{id:"linux-namespaces",children:"Linux namespaces"}),"\n",(0,s.jsx)(n.p,{children:"Linux namespaces nos permite crear ambientes virtuales y aislados, estos particionan recursos del kernel y hacen que  sean visibles solo para los procesos que corren dentro del namespace, pero no para procesos externos. En otras palabras, namespaces nos facilitan el aislamiento entre procesos."}),"\n",(0,s.jsxs)(n.p,{children:["\xbfQu\xe9 recursos se pueden particionar?, bueno esto va a depender del ",(0,s.jsx)(n.a,{href:"https://www.redhat.com/sysadmin/7-linux-namespaces",children:"tipo de namespace"})," que se este usando, por ejemplo, network namespaces nos permite encapsular los recursos relacionados con networking, como interfaces, tablas de rutas, etc. De esta forma podemos crear una red virtual dentro de nuestro namespace."]}),"\n",(0,s.jsxs)(n.p,{children:["Este ",(0,s.jsx)(n.a,{href:"https://www.redhat.com/sysadmin/7-linux-namespaces",children:"post"})," explica un poco m\xe1s en detalle los namespaces."]}),"\n",(0,s.jsx)(n.h3,{id:"cgroups",children:"cgroups"}),"\n",(0,s.jsx)(n.p,{children:"Recordemos que el Kernel de Linux es la interfaz principal entre el hardware y los procesos, permitiendo la comunicaci\xf3n entre estos dos y ayudando a la gesti\xf3n de recursos, por ejemplo, puede terminar procesos que consuman demasiada memoria para evitar afectar el sistema operativo. Adicionalmente pueden controlar qu\xe9 procesos pueden consumir cierta cantidad de recursos."}),"\n",(0,s.jsx)(n.p,{children:"cgroups es una funcionalidad del Kernel de Linux que permite organizar jer\xe1rquicamente procesos y distribuir recursos(cpu, memoria, networking, storage) dentro de dicha jerarqu\xeda."}),"\n",(0,s.jsxs)(n.p,{children:["Configurar cgroups puede ser un poco complejo, en mi caso estuve leyendo varios post acerca del tema y requiere cierto tiempo para entender por completo su funcionamiento. En esta ",(0,s.jsx)(n.a,{href:"https://www.redhat.com/sysadmin/cgroups-part-one",children:"serie de posts"})," creados por RedHat se habla sobe cgroups y su configuraci\xf3n a trav\xe9s de systemd, pero si se desea entrar en detalle la ",(0,s.jsx)(n.a,{href:"https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/cgroups.html",children:"documentaci\xf3n de Linux"})," puede ser de ayuda."]}),"\n",(0,s.jsx)(n.p,{children:"cgroups y namespaces se convierten en los ingredientes secretos en la creaci\xf3n de containers, namespaces permiten aislamiento a nivel de recursos y cgroups permiten controlar los limites para dichos recursos."}),"\n",(0,s.jsx)(n.p,{children:"Por suerte hoy en d\xeda con una sola linea podemos crear un container, no tenemos que entrar a configurar namespaces ni cgroups."}),"\n",(0,s.jsx)(n.p,{children:"Veamos un poco de la evoluci\xf3n de los containers y as\xed vamos aclarando ciertas cosas."}),"\n",(0,s.jsx)(n.h3,{id:"un-poco-de-historia",children:"Un poco de historia"}),"\n",(0,s.jsx)(n.p,{children:"Docker fue el primero que populariz\xf3 los containers, era(o es) com\xfan asociar containers directamente con Docker, pero antes ya exist\xeda algo llamado LXC(Linux containers), el cual puede entenderse como un proveedor de ambientes virtuales en Linux que usa ciertos componentes del Kernel de Linux para crear ambientes aislados(containers)."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jquo7g5j5iusxgy42wv3.png",alt:"Image lxc"})}),"\n",(0,s.jsxs)(n.p,{children:["LXC se encuentra dentro del user-space, es decir, nosotros interactuamos con LXC y este se encarga de interactuar con los componentes del kernel para permitir la creaci\xf3n de containers. Aqui un ",(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=aIwgPKkVj8s",children:"video"})," en donde se puede ver LXC en acci\xf3n."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Nota:"})," Antes de LXC ya se hab\xedan desarrollado otros alternativas para la creaci\xf3n de containers como OpenVZ y Linux Vserver. LXC es mencionado inicialmente ya que es lo m\xe1s cercano a Docker que es el software con el que muchos iniciamos interactuando con containers."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"la-llegada-de-docker",children:"La llegada de Docker"}),"\n",(0,s.jsxs)(n.p,{children:["Docker empaquet\xf3 LXC en una herramienta que facilitaba m\xe1s la creaci\xf3n de containers. Al ganar popularidad se crearon mejoras y unos meses despu\xe9s Docker lanz\xf3 ",(0,s.jsx)(n.a,{href:"https://github.com/opencontainers/runc/tree/main/libcontainer",children:"libcontainer"})," el cual est\xe1 escrito en ",(0,s.jsx)(n.a,{href:"https://github.com/opencontainers/runc/tree/main/libcontainer",children:"Golang"})," y b\xe1sicamente reemplazaba LXC."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ydjpgj8o2rmm15btbqet.png",alt:"Docker libcontainer"})}),"\n",(0,s.jsxs)(n.p,{children:["Docker se enfoc\xf3 m\xe1s en la creaci\xf3n de containers optimizados para el despliegue de aplicaciones mejorando la portabilidad. Este ",(0,s.jsx)(n.a,{href:"https://earthly.dev/blog/lxc-vs-docker/",children:"post"})," explica m\xe1s detalladamente las diferencias entre LXC y Docker."]}),"\n",(0,s.jsx)(n.h4,{id:"definiendo-un-est\xe1ndar-para-containers",children:"Definiendo un est\xe1ndar para containers"}),"\n",(0,s.jsxs)(n.p,{children:["Como alternativa a Docker, empezaron a surgir otras opciones,CoreOS por su parte lanz\xf3 ",(0,s.jsx)(n.a,{href:"https://www.redhat.com/en/topics/containers/what-is-rkt",children:"rkt(2014)"})," proponiendo mejores de seguridad, CoreOS ",(0,s.jsx)(n.a,{href:"https://lwn.net/Articles/623875/",children:"argumentaba"})," que Docker hab\xeda sido construido como un monolito el cual corr\xeda como root en el host, abriendo posibilidades a comprometer todo el host en el caso de un ataque."]}),"\n",(0,s.jsxs)(n.p,{children:["rkt usa ",(0,s.jsx)(n.a,{href:"https://github.com/appc",children:"appc(open source container)"})," con el fin de mejorar la operabilidad, appc tiene como prop\xf3sito crear un est\xe1ndar general para crear containers buscando ser vendor-independent y OS-independent."]}),"\n",(0,s.jsxs)(n.p,{children:["Otras iniciativas empezaron a surgir debido a la alta popularidad de los containers y debido a esto, en 2015 se crea ",(0,s.jsx)(n.a,{href:"https://opencontainers.org/about/overview/",children:"OCI(Open Container Initiative)"})," para definir un estandar para containers(",(0,s.jsx)(n.a,{href:"https://github.com/opencontainers/runtime-spec/blob/main/spec.md",children:"runtimes"})," e ",(0,s.jsx)(n.a,{href:"https://github.com/opencontainers/image-spec/blob/main/spec.md",children:"imagenes"}),")."]}),"\n",(0,s.jsx)(n.h4,{id:"oci-runtime-spec",children:"OCI Runtime spec"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Runtime spec"})," define la configuraci\xf3n(archivo JSON), ambiente y ciclo de vida de un container. Las configuraciones son definidas en un archivo llamado config.json, el cual contiene la metadata necesaria para la ejecuci\xf3n del container, este archivo es definido de acuerdo a plataforma a usar(windows, linux, solaris, etc)."]}),"\n",(0,s.jsxs)(n.p,{children:["otro concepto a destacar es el ",(0,s.jsx)(n.em,{children:"filesystem bundle"}),", este es un grupo de archivos con la data y metadata para correr un container. Los principales archivos que deben contener son, el config.json mencionado anteriormente y el ",(0,s.jsx)(n.a,{href:"https://www.baeldung.com/linux/rootfs",children:"rootfs(linux file system)"}),", este  ",(0,s.jsx)(n.em,{children:"filesystem bundle"})," se genera a trav\xe9s del container image."]}),"\n",(0,s.jsxs)(n.p,{children:["Todas las especificaciones para el container runtime son descritas ",(0,s.jsx)(n.a,{href:"https://github.com/opencontainers/runtime-spec/blob/main/spec.md",children:"aqui"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"oci-image-spec",children:"OCI Image spec"}),"\n",(0,s.jsxs)(n.p,{children:["Docker en sus inicios ya hab\xeda definido las especificaciones para la creaci\xf3n de im\xe1genes",(0,s.jsx)(n.a,{href:"https://docs.docker.com/registry/spec/manifest-v2-2/",children:"Image Manifest 2 Schema Version 2"}),", al ser el m\xe1s popular, OCI parti\xf3 de este para crear un est\xe1ndar m\xe1s general, que no estuviera asociado a un vendor en espec\xedfico. ",(0,s.jsx)(n.em,{children:"Image spec"})," define como construir y empaquetar container images, personalmente no he entendido del todo el funcionamiento pero aqu\xed est\xe1 la url del ",(0,s.jsx)(n.a,{href:"https://github.com/opencontainers/image-spec",children:"repo"})," y un ",(0,s.jsx)(n.a,{href:"https://blog.quarkslab.com/digging-into-the-oci-image-specification.html",children:"blog-post"})," que contienen mayor informaci\xf3n."]}),"\n",(0,s.jsxs)(n.p,{children:["Haciendo uso del ",(0,s.jsx)(n.em,{children:"Image spec"}),", se puede crear un container image que puede ser ejecutada por cualquier ",(0,s.jsx)(n.em,{children:"OCI Runtime"}),", esto quiere decir que a trav\xe9s del ",(0,s.jsx)(n.em,{children:"Image spec"})," se puede generar el ",(0,s.jsx)(n.em,{children:"filesystem bundle"}),", el cual es usado por el runtime para la creaci\xf3n y ejecuci\xf3n del container."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'The Runtime Specification outlines how to run a "filesystem bundle" that is unpacked on disk. At a high-level an OCI implementation would download an OCI Image then unpack that image into an OCI Runtime filesystem bundle. At this point the OCI Runtime Bundle would be run by an OCI Runtime.'}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"container-runtimes-y-kubernetes",children:"Container runtimes y Kubernetes"}),"\n",(0,s.jsx)(n.p,{children:"En el 2015 se lanza el primer release de kubernetes, el cual usaba Docker como runtime."}),"\n",(0,s.jsx)(n.p,{children:"Docker decide dividir el monolito creado. libcontainer es donado a OCI y Docker empieza a trabajar en un proyecto llamado runC, este se puede ver como una herramienta que lee OCI specifications e interact\xfaa con libcontainer para la creaci\xf3n de containers. runC es independiente del Docker Engine y es donado a OCI."}),"\n",(0,s.jsxs)(n.p,{children:["runC es una low-level runtime por lo que tambi\xe9n se desarrolla ",(0,s.jsx)(n.em,{children:"containerd"})," el cual es como una interfaz entre el cliente y runC."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/zi3mkr4s6u5bbmj3y9ls.png",alt:"docker-runc-containerd",title:"fuente: https://images.techhive.com/images/article/2016/04/docker-runc-100656060-large.idge.png"})}),"\n",(0,s.jsxs)(n.p,{children:["Hasta el momento solo se ha cubierto parte del origen de los container y el origen de algunas herramientas que seguimos viendo hoy en d\xeda como runC y conteinerd. En lo que sigue del post tratar\xe9 de exponer un poco m\xe1s a fondo las ",(0,s.jsx)(n.em,{children:"container images"})," al igual que algunas ",(0,s.jsx)(n.em,{children:"containers runtimes"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"container-images",children:"Container Images"}),"\n",(0,s.jsxs)(n.p,{children:["Antes de entrar a ver las ",(0,s.jsx)(n.em,{children:"containers runtimes"}),", es importante entender qu\xe9 es lo que contienen las ",(0,s.jsx)(n.em,{children:"containers images"}),", para ello vamos a usar ",(0,s.jsx)(n.a,{href:"https://www.redhat.com/en/topics/containers/what-is-skopeo",children:"Skopeo"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Skopeo permite manipular e inspeccionar ",(0,s.jsx)(n.em,{children:"container images"}),' ya sea para Windows, Linux o MacOs. En este caso vamos a usar Skopeo para obtener "el contenido" de una imagen que se encuentra en DockerHub, esto es muy similar al comando ',(0,s.jsx)(n.a,{href:"https://docs.docker.com/engine/reference/commandline/export/",children:"docker export"}),",pero en este caso no vamos a instalar Docker."]}),"\n",(0,s.jsx)(n.h4,{id:"copiando-images-con-skopeo",children:"copiando images con skopeo"}),"\n",(0,s.jsx)(n.p,{children:"Para instalar skopeo se puede usar snap en ubuntu"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo snap install skopeo --edge\n"})}),"\n",(0,s.jsx)(n.p,{children:"una vez que finalice la instalaci\xf3n podemos copiar una imagen que se encuentra en DockerHub a nuestro local. En este caso se va a usar la imagen de golang."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo skopeo --insecure-policy copy docker://golang:latest  oci://home/ubuntu/example-dev-to/golang-image-v2\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Skopeo copia el contenido de la imagen en el destino especificado, en este caso ",(0,s.jsx)(n.code,{children:"oci:/home/ubuntu/example-dev-to/golang-image-v2"}),". En la imagen se puede ver que se tiene un archivo index.json, oci-layout y un directorio llamado blobs. Esto corresponde a la estructura de archivos definidos por ",(0,s.jsx)(n.a,{href:"https://github.com/opencontainers/image-spec/blob/main/spec.md",children:"OCI"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/f76zraaa4bdgws82wr9f.png",alt:"golang-copy-skopeo"})}),"\n",(0,s.jsxs)(n.p,{children:["el ",(0,s.jsx)(n.em,{children:"index.json"})," se puede entender como un resumen de la imagen, en donde se ve el sistema operativo y la arquitectura, adem\xe1s se especifica la ubicaci\xf3n del ",(0,s.jsx)(n.em,{children:"image manifest"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["El ",(0,s.jsx)(n.em,{children:"image manifest"})," contiene metadata de la imagen al igual que las especificaciones de cada layer creada."]}),"\n",(0,s.jsx)(n.p,{children:"Revisando el index.json vamos a encontrar lo siguiente:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wxaqowqg0vbmhjvsgvsq.png",alt:"index.json golang image"})}),"\n",(0,s.jsx)(n.p,{children:"Se puede ver informaci\xf3n acerca del sistema operativo y arquitectura soportados por la imagen. El digest(linea 6) nos indica en que archivo se encuentra el manifest.json."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7tyogxsh5q90vgolsvbu.png",alt:"manifest"})}),"\n",(0,s.jsxs)(n.p,{children:["En el manifest(imagen anterior) se puede ver el digest para el config file y para cada una de las layers que se tienen. El ",(0,s.jsx)(n.a,{href:"https://github.com/opencontainers/image-spec/blob/main/media-types.md",children:"mediaType"})," puede entenderse como el formato de cada archivo, por ejemplo la linea 4 nos dice que el archivo config de formato json se puede identificar con el digest ",(0,s.jsx)(n.code,{children:"bdba673e96d6e9707e2a724103e8835dbdd11dc81ad0c76c4453066ed8db29fd"}),". Este se puede encontrar en la carpeta blobs y va a lucir como la siguiente imagen."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/74dolefjcdzij0qhcf3d.png",alt:"config.json"})}),"\n",(0,s.jsx)(n.p,{children:"Este archivo ya contiene m\xe1s informaci\xf3n de la imagen, por ejemplo podemos ver el workdir y algunas variables de entorno."}),"\n",(0,s.jsxs)(n.p,{children:["pasemos ahora a las layers, en el manifest podemos identificar los digest para cada layers, si vemos el media type nos indica que es ",(0,s.jsx)(n.code,{children:"v1.tar+gzip"}),", en este caso tenemos que descomprimir el contenido de dicho digest, para ello vamos a usar ",(0,s.jsx)(n.code,{children:"tar"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/fd5iwfpygp71jutt0qcx.png",alt:"unpackage-digest"})}),"\n",(0,s.jsx)(n.p,{children:"Una vez termine el proceso podemos analizar el resultado, en este caso vamos a tener una serie de directorios que representan el rootfs de la imagen, estos archivos van a hacer parte de un layer en espec\xedfico. Si observamos la siguente imagen podemos ver que tenemos /home, /etc y /bin, etc, los cuales representan el sistema de archivos de linux(rootfs)."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/clm54sgl7p2i08gtrd1b.png",alt:"rootfs"})}),"\n",(0,s.jsxs)(n.p,{children:["Con esto vemos a alto nivel el contenido de un ",(0,s.jsx)(n.em,{children:"container image"}),", al final el ",(0,s.jsx)(n.em,{children:"container runtime"})," es el que se encarga de descomprimir y leer todos estos archivos, el cual va a ser usado para correr el container."]}),"\n",(0,s.jsx)(n.p,{children:"Hasta aqu\xed va la primera parte de este post, en la siguiente veremos un poco m'as los container runtimes."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>c});var s=a(6540);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);