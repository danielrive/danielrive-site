"use strict";(self.webpackChunkdanielrive_site=self.webpackChunkdanielrive_site||[]).push([[6424],{4112:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var n=s(4848),i=s(8453);const r={slug:"fluxcd",title:"GitOps with FluxCD",authors:["danielrivera"],tags:["aws","SmartCash-Project","kubernetes"]},o=void 0,a={permalink:"/blog/fluxcd",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-11-04-GitOps-with-FluxCD.md",source:"@site/blog/2023-11-04-GitOps-with-FluxCD.md",title:"GitOps with FluxCD",description:"GitOps meme, source https://blog.kubesimplify.com/gitops-demystified",date:"2023-11-04T00:00:00.000Z",tags:[{inline:!1,label:"AWS",permalink:"/blog/tags/aws",description:"Content related with AWS"},{inline:!0,label:"SmartCash-Project",permalink:"/blog/tags/smart-cash-project"},{inline:!1,label:"Kubernetes",permalink:"/blog/tags/kubernetes",description:"Content related with Kubernetes"}],readingTime:8.455,hasTruncateMarker:!0,authors:[{name:"Daniel German Rivera",title:"Cloud Engineer",url:"https://github.com/danielrive",page:{permalink:"/blog/authors/danielrivera"},socials:{github:"https://github.com/danielrive",linkedin:"https://www.linkedin.com/in/danielrive/"},key:"danielrivera"}],frontMatter:{slug:"fluxcd",title:"GitOps with FluxCD",authors:["danielrivera"],tags:["aws","SmartCash-Project","kubernetes"]},unlisted:!1,prevItem:{title:"Adding monitoring to EKS using Prometheus operator",permalink:"/blog/EKS-Prometheus"},nextItem:{title:"AWS Infrastructure Terraform and GitHub Actions",permalink:"/blog/github-actions"}},l={authorsImageUrls:[void 0]},c=[{value:"Source code",id:"source-code",level:2},{value:"A quick introduction to GitOps",id:"a-quick-introduction-to-gitops",level:2},{value:"What is FluxCD",id:"what-is-fluxcd",level:3},{value:"Installing FluxCD in the cluster",id:"installing-fluxcd-in-the-cluster",level:2},{value:"Adding FluxCD bootstrap script to terraform code",id:"adding-fluxcd-bootstrap-script-to-terraform-code",level:3},{value:"Structuring the Git repository",id:"structuring-the-git-repository",level:2},{value:"Adding resources to the cluster",id:"adding-resources-to-the-cluster",level:2},{value:"Troubleshooting",id:"troubleshooting",level:3},{value:"Creating a Helm release for nginx-ingress",id:"creating-a-helm-release-for-nginx-ingress",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/t18cxoi3v9353gucvs2p.png",alt:"GitOps meme, source https://blog.kubesimplify.com/gitops-demystified"})}),"\n",(0,n.jsxs)(t.p,{children:["In a ",(0,n.jsx)(t.a,{href:"https://dev.to/aws-builders/smartcash-project-infrastructure-terraform-and-github-actions-2bo3",children:"previous article"})," I mentioned the idea behind this project that I named SmartCash. I began building the terraform code for the infrastructure in AWS and the pipeline to deploy it."]}),"\n",(0,n.jsx)(t.p,{children:"In this article, I will introduce FluxCD as a GitOps tool and demonstrate its usage."}),"\n",(0,n.jsx)(t.h2,{id:"source-code",children:"Source code"}),"\n",(0,n.jsxs)(t.p,{children:["A new release has been created in the smart-cash repository for the project. v1.1.0 version will be used, you can check the repository ",(0,n.jsx)(t.a,{href:"https://github.com/danielrive/smart-cash/tree/v1.1.0",children:"here"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Additionally, a new repository will be created to store the K8 manifest that will be synced with the EKS cluster using FluxCD, you can view the repo ",(0,n.jsx)(t.a,{href:"https://github.com/danielrive/smart-cash-gitops-flux",children:"here"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"a-quick-introduction-to-gitops",children:"A quick introduction to GitOps"}),"\n",(0,n.jsx)(t.p,{children:"GitOps is an operational model for cloud-native architectures,  it relies on a Git repository as the single source of truth. New commits imply infrastructure and application updates."}),"\n",(0,n.jsxs)(t.p,{children:["OpenGitOps group has defined 5 principles, and while I won't delve into them, ",(0,n.jsx)(t.a,{href:"https://opengitops.dev/",children:"here"}),", you can read more. If you take a look at those principles you will see that they are, in some sense related to some Kubernetes concepts."]}),"\n",(0,n.jsxs)(t.p,{children:["A great book to gain a better understanding of GitOps history and concepts is ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://developers.redhat.com/e-books/path-gitops",children:"The Path to GitOps"})}),"."]}),"\n",(0,n.jsx)(t.p,{children:"In summary, GitOps is centered around using a Git repository for defining and managing both infrastructure and application configurations through a Git-based workflow."}),"\n",(0,n.jsx)(t.h3,{id:"what-is-fluxcd",children:"What is FluxCD"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://fluxcd.io/",children:"FluxCD"})," is an open-source GitOps operator for Kubernetes, you can declaratively define the desired state of your infrastructure and configurations in a Git repository. Flux monitors the repository and applies updates to the Kubernetes cluster when new changes arrive."]}),"\n",(0,n.jsx)(t.p,{children:"Flux started as a monolith but in v2 it was broken up into individual components called GitOps Toolkit, this refers collection of specialized tools, Flux Controllers, composable APIs, and reusable Go packages available under the fluxcd GitHub organization."}),"\n",(0,n.jsxs)(t.p,{children:["Core concepts and toolkit components are described ",(0,n.jsx)(t.a,{href:"https://www.weave.works/technologies/what-is-flux-cd/",children:"here"}),"."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hv4kfhyq6yq90x3e27wh.png",alt:"hands-on"})}),"\n",(0,n.jsx)(t.h2,{id:"installing-fluxcd-in-the-cluster",children:"Installing FluxCD in the cluster"}),"\n",(0,n.jsxs)(t.p,{children:["FluxCD ",(0,n.jsx)(t.a,{href:"https://fluxcd.io/flux/installation/",children:"installation"})," can be done by Flux CLI, the most straightforward method can be done by the ",(0,n.jsxs)(t.a,{href:"https://fluxcd.io/flux/installation/bootstrap/",children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.em,{children:"flux bootstrap"})})," command"]}),", this deploys the Flux controllers on the K8 cluster and configures them to synchronize the cluster to the Git repository, if the Git Repo doesn't exist, the bootstrap command will create it."]}),"\n",(0,n.jsx)(t.p,{children:"To incorporate FluxCD installation into this project a new bash script has been added into the repository that contains the terraform code, this bash script will be execute by terraform as a null resource."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:'#/bin/bash\n\n## Configure Cluster Credentials\n\n# $1 = CLUSTER_NAME\n# $2 = AWS_REGION\n# $3 = GH_USER_NAME\n# $4 = FLUX_REPO_NAME\n\necho "----------\x3e  get eks credentials"\naws eks update-kubeconfig --name $1  --region $2\n\n## validate if flux is installed\n\nflux_installed=$(kubectl api-resources | grep flux)\nif [ -z "$flux_installed" ]; then\n  echo "----------\x3e  flux is not installed"\n\n  ### install flux\n\n  echo "----------\x3e  installing flux cli"\n\n  curl -s https://fluxcd.io/install.sh | sudo bash\n\n  echo "----------\x3e  run flux bootstrap"\n  flux bootstrap github \\\n    --owner=$3 \\\n    --repository=$4 \\\n    --path="clusters/$1/bootstrap" \\\n    --branch=main \\\n    --personal\nelse\n  echo "----------\x3e  flux is installed"\nfi\n'})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"flux bootstrap github"})," command deploys the Flux controllers on the K8 cluster and configures the controllers to synchronize the Git repo with the cluster. This is done by some K8 manifests that are created and pushed to the repo in the path passed in the command."]}),"\n",(0,n.jsx)(t.p,{children:"It's worth noting that some env variables like FLUX_REPO_NAME, and GH_USER_NAME are used by the bash script, these variables are passed as an argument in the bash script execution."}),"\n",(0,n.jsx)(t.h3,{id:"adding-fluxcd-bootstrap-script-to-terraform-code",children:"Adding FluxCD bootstrap script to terraform code"}),"\n",(0,n.jsx)(t.p,{children:"The bash script will be executed in the GH workflow template created to deploy the infrastructure, the following job is added to the Workflow template."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-terraform",children:'#### bash script arguments\n  # $1 = CLUSTER_NAME\n  # $2 = AWS_REGION\n  # $3 = GH_USER_NAME\n  # $4 = FLUX_REPO_NAME\n\nresource "null_resource" "bootstrap-flux" {\n  depends_on          = [module.eks_cluster]\n  provisioner "local-exec" {\n    command = <<EOF\n    ./scripts/bootstrap-flux.sh ${local.cluster_name}  ${var.region} ${local.gh_username} ${data.github_repository.flux-gitops.name}\n    EOF\n  }\n  triggers = {\n    cluster_oidc = module.eks_cluster.cluster_oidc\n    created_at   = module.eks_cluster.created_at\n  }\n\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Notice that the ",(0,n.jsx)(t.em,{children:"GITHUB_TOKEN"})," variable is passed directly in the Github job."]}),"\n",(0,n.jsx)(t.p,{children:"Once the workflow is ready you can push it to the repo and see how terraform will create all the infra and after EKS cluster creation will execute the bash script."}),"\n",(0,n.jsxs)(t.p,{children:["You can run ",(0,n.jsx)(t.strong,{children:"flux check"})," command locally to validate the status of the installation(you should have access to the cluster in your local env)"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/czt08fmy5h10p2gq0na3.png",alt:"flux-check"})}),"\n",(0,n.jsxs)(t.p,{children:["If you take a look at the above image you will see that the Source Controller is deployed, ",(0,n.jsx)(t.a,{href:"https://fluxcd.io/flux/components/source/",children:"Source Controller"})," enables seamless integration of various Git repositories with your Kubernetes cluster. Think of the Source Controller as an interface to connect with GitRepositories, OCIRepository, HelmRepository, and Bucket resources."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.code,{children:"\u2714 source-controller: deployment ready"})}),"\n",(0,n.jsx)(t.p,{children:"The bootstrap command will create a flux source and associate it to the repo passed in the command, to validate this you can list the git sources created and you will see the one, for now."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"flux get sources git\n"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/kjtan9rnhp0qc9mb6l02.png",alt:"Flux-git-source"})}),"\n",(0,n.jsx)(t.p,{children:"and you can see the K8 CDRs created"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.code,{children:"kubectl get crds | grep flux"})}),"\n",(0,n.jsx)(t.h2,{id:"structuring-the-git-repository",children:"Structuring the Git repository"}),"\n",(0,n.jsxs)(t.p,{children:["There are different strategies to structure the GitOps repository, for this scenario, a mono-repo strategy is used and ",(0,n.jsx)(t.a,{href:"https://kustomize.io/",children:"kustomize"})," will be used to manage the K8 manifest for the application."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"./clusters"}),": contains all the cluster associated with the project, cluster for each environment or region should be placed here."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"./clusters/smart-cash-develop/bootstrap:"})," Yaml files created by fluxcd installation, also there is a file name ",(0,n.jsx)(t.strong,{children:"core-kustomization.yaml"})," that points to a core folder that manages the manifests."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"./clusters/smart-cash-develop/core:"})," Contains the main manifest for the project, manifest like FluxSources, and also kustomization files. Here will be placed the kustomization file for each microservice that will be created."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"./clusters/smart-cash-develop/core:"})," Manifests that create common resources for the cluster like namespaces, ingress, storage-classes, etc."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Manifests:"})," This contains subfolders that contain the YAML files for each microservices."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-txt",children:"\u251c\u2500\u2500 clusters\n    \u2514\u2500\u2500 smart-cash-develop\n        |\u2500\u2500 bootstrap\n        |\u2500\u2500 common\n        |   |\u2500\u2500 ingress-namespace.yaml\n        |   \u2514\u2500\u2500 namespaces.yaml\n        |\u2500\u2500 core\n        |   |\u2500\u2500 common-kustomize.yaml\n        |   \u2514\u2500\u2500 helm-cert-manager.yaml\n        \u2514\u2500\u2500 manifests\n            \u2514\u2500\u2500 app1\n                |\u2500\u2500 base\n                |   |\u2500\u2500 kustomization.yaml\n                |   \u2514\u2500\u2500 deployment.yaml\n                \u2514\u2500\u2500 overlays\n                    |\u2500\u2500 develop\n                    |   \u2514\u2500\u2500 kustomization.yaml\n                    \u2514\u2500\u2500 production\n                        \u2514\u2500\u2500 kustomization.yaml \n"})}),"\n",(0,n.jsx)(t.h2,{id:"adding-resources-to-the-cluster",children:"Adding resources to the cluster"}),"\n",(0,n.jsxs)(t.p,{children:["Let's create a K8 namespace to be used for an nginx-ingress. The manifest for this can be placed in the ",(0,n.jsx)(t.em,{children:"common"})," folder. A FluxCD Kustomization can be added to synchronize the contents of this folder with the K8 cluster."]}),"\n",(0,n.jsxs)(t.p,{children:["The following is the Flux Kustomization that reconciles the Kubernetes manifests located at the path ",(0,n.jsx)(t.em,{children:"./common"})," in the Git repository ."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Note:"})," This file can be added in ",(0,n.jsx)(t.em,{children:"clusters/smart-cash-develop"})," folder, FluxCD will automatically create the Kustomization resource because this path was specified in the bootstrap command, and Flux created a Kustomization to synchronize it."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-YAML",children:'apiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\n  name: smartcash-common\n  namespace: flux-system\nspec:\n  interval: 5m\n  targetNamespace: default\n  sourceRef:\n    kind: GitRepository\n    name: flux-system\n  path: "./kustomize"\n  prune: true\n'})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"interval:"})," The period at which the Kustomization is reconciled."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"sourceRef:"})," refers to the Source object with the required Artifacts, in this case, our GitOps repository."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"prune:"}),": When is true, if previously applied objects are missing from the current revision, these objects are deleted from the cluster"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Once you push the Yaml file to the GitOps repo, Flux will create the resources in the cluster. You can validate running:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.code,{children:"kubectl get kustomization -n flux-system"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/s0aqez3paizw42s38imz.png",alt:"common-kustomization"})}),"\n",(0,n.jsxs)(t.p,{children:["The previous steps have created the FluxCD Kustomization to sync the ",(0,n.jsx)(t.em,{children:"common"})," folder with the cluster. Now, a Kustomize file needs to be added to specify which resource to create."]}),"\n",(0,n.jsxs)(t.p,{children:["Don't confuse the ",(0,n.jsx)(t.a,{href:"https://fluxcd.io/flux/components/kustomize/kustomizations/#path",children:"FluxCD Kustomization"})," file with the K8 configuration management ",(0,n.jsx)(t.a,{href:"https://kustomize.io/",children:"Kustomize"}),". FluxCD will look for the Kustomize file in the ",(0,n.jsx)(t.em,{children:"common"})," folder."]}),"\n",(0,n.jsxs)(t.p,{children:["Let's create and push the following files in the ",(0,n.jsx)(t.em,{children:"common"})," folder."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-YAML",children:"apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nresources:\n- ns-nginx-ingress.yaml\n"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-YAML",children:"apiVersion: v1\nkind: Namespace\nmetadata:\n  name: nginx-ingress\n"})}),"\n",(0,n.jsx)(t.p,{children:"You can wait for the flux reconciliation or force it using the following command:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"flux reconcile kustomization smartcash-common\n"})}),"\n",(0,n.jsx)(t.p,{children:"If the process was successful you should see the nginx-ingress namespace."}),"\n",(0,n.jsx)(t.h3,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,n.jsx)(t.p,{children:"To validate the status of the reconciliation you can use the following command:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"flux get kustomization smartcash-common\n"})}),"\n",(0,n.jsx)(t.p,{children:"For instance, a mistake in the name of the YAML files caused this error, which was visible in the output of the flux command."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2gdw0r19wyk1r285c7hz.png",alt:"Flux-error"})}),"\n",(0,n.jsx)(t.p,{children:"If you want more details you can check the K8 CDRs using:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"kubectl describe kustomization smartcash-common -n flux-system \n"})}),"\n",(0,n.jsx)(t.h2,{id:"creating-a-helm-release-for-nginx-ingress",children:"Creating a Helm release for nginx-ingress"}),"\n",(0,n.jsxs)(t.p,{children:["The Flux Helm Controller will be used to install the ingress. ",(0,n.jsx)(t.a,{href:"https://fluxcd.io/flux/components/helm/",children:"The Helm Controller"})," is a Kubernetes operator that enables the management of Helm chart releases."]}),"\n",(0,n.jsxs)(t.p,{children:["A FluxCD source for Helm needs to be added. This can be accomplished by using the following manifest, which should be placed in ",(0,n.jsx)(t.em,{children:"clusters/smart-cash-develop"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-YAML",children:"apiVersion: source.toolkit.fluxcd.io/v1beta2\nkind: HelmRepository\nmetadata:\n  name: helm-repo-nginx-ingress\n  namespace: flux-system\nspec:\n  interval: 5m0s\n  type: oci\n  url: oci://ghcr.io/nginxinc/charts\n"})}),"\n",(0,n.jsx)(t.p,{children:"This source fetches the Helm OCI repository oci://ghcr.io/nginxinc/charts every 5 minutes, and the artifact is stored and updated each time new updates are done to the repository."}),"\n",(0,n.jsx)(t.p,{children:"After creating the Helm source, you can proceed to create the Helm release. This release specifies the chart to install in the cluster, with the chart being fetched from the source already created. The following manifest can be used."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:"apiVersion: helm.toolkit.fluxcd.io/v2beta1\nkind: HelmRelease\nmetadata:\n  name: nginx-ingress\n  namespace: nginx-ingress\nspec:\n  interval: 10m0s\n  chart:\n    spec:\n      chart: nginx-ingress\n      version: 0.17.1\n      sourceRef:\n        kind: HelmRepository\n        name: helm-repo-nginx-ingress\n        namespace: flux-system\n\n"})}),"\n",(0,n.jsx)(t.p,{children:"To delegate the creation of the HelmRelease task to flux, this file can be added to the common folder and in the Kustomize file as well."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-YAML",children:"apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nresources:\n- ns-nginx-ingress.yaml\n- nginx-ingress-helm.yaml\n"})}),"\n",(0,n.jsx)(t.p,{children:"After updating and pushing the files, you can validate the creation of the Helm Release and nginx-ingress resources."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-YAML",children:"flux get helmreleases -n nginx-ingress\n"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ui87g1erg9j42rc1ost4.png",alt:"Helm-releases"})}),"\n",(0,n.jsx)(t.p,{children:"Up to this point, we've covered the second phase of this project. In the upcoming articles, you'll delve into the implementation of various other tools and continue building the project."}),"\n",(0,n.jsxs)(t.p,{children:["If you have any feedback or suggestions, please feel free to reach out to me on ",(0,n.jsx)(t.a,{href:"https://www.linkedin.com/in/danielrive/",children:"LinkedIn"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>a});var n=s(6540);const i={},r=n.createContext(i);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);