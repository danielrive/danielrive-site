"use strict";(self.webpackChunkdanielrive_site=self.webpackChunkdanielrive_site||[]).push([[1583],{656:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=t(4848),s=t(8453);const i={slug:"github-actions",title:"AWS Infrastructure Terraform and GitHub Actions",authors:["danielrivera"],tags:["aws","SmartCash-Project"]},a=void 0,o={permalink:"/blog/github-actions",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-10-25-AWS-Infrastructure-Terraform-and-GitHub-Actions.md",source:"@site/blog/2023-10-25-AWS-Infrastructure-Terraform-and-GitHub-Actions.md",title:"AWS Infrastructure Terraform and GitHub Actions",description:"gh-actions",date:"2023-10-25T00:00:00.000Z",tags:[{inline:!1,label:"AWS",permalink:"/blog/tags/aws",description:"Content related with AWS"},{inline:!0,label:"SmartCash-Project",permalink:"/blog/tags/smart-cash-project"}],readingTime:8.34,hasTruncateMarker:!0,authors:[{name:"Daniel German Rivera",title:"Cloud Engineer",url:"https://github.com/danielrive",page:{permalink:"/blog/authors/danielrivera"},socials:{github:"https://github.com/danielrive",linkedin:"https://www.linkedin.com/in/danielrive/"},key:"danielrivera"}],frontMatter:{slug:"github-actions",title:"AWS Infrastructure Terraform and GitHub Actions",authors:["danielrivera"],tags:["aws","SmartCash-Project"]},unlisted:!1,prevItem:{title:"GitOps with FluxCD",permalink:"/blog/fluxcd"},nextItem:{title:"Containers - entre historia y runtimes",permalink:"/blog/containers-history"}},l={authorsImageUrls:[void 0]},c=[{value:"Source Code",id:"source-code",level:3},{value:"Architecture",id:"architecture",level:3},{value:"IaC",id:"iac",level:3},{value:"Networking",id:"networking",level:4},{value:"EKS",id:"eks",level:4},{value:"Infrastructure Pipeline",id:"infrastructure-pipeline",level:2},{value:"Branch strategy",id:"branch-strategy",level:3},{value:"GitHub Actions",id:"github-actions",level:3},{value:"actions folder",id:"actions-folder",level:4},{value:"jobs",id:"jobs",level:4},{value:"Workflows",id:"workflows",level:4},{value:"Workflow Template",id:"workflow-template",level:5},{value:"Using the template",id:"using-the-template",level:5}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"gh-actions",src:t(9913).A+"",width:"1024",height:"524"})}),"\n",(0,r.jsx)(n.p,{children:"The journey to learn a new tool can be a little tricky, watching videos and reading some blogs can be an option, but watching and reading can not be enough for everyone, personally I need a hands-on approach for effective learning."}),"\n",(0,r.jsx)(n.p,{children:'That motivation drove me to embark on a personal project where I could implement the tools I had been using and those I wanted to explore. to initiate this journey I decided to create an application that helped me to follow my expenses, it could be something trivial but I needed a "business case" to begin building a solution.'}),"\n",(0,r.jsx)(n.p,{children:"The general idea is to have an application that helps you track the monthly expenses and filter for a particular category to see where the money is going."}),"\n",(0,r.jsx)(n.p,{children:"Let's start building the initial infrastructure needed for the application."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://dev.to/aws-builders/smartcash-project-gitops-with-fluxcd-3aep",children:"Here"})," you can find the GitOps implementation(Part 2 of the project)."]}),"\n",(0,r.jsx)(n.h3,{id:"source-code",children:"Source Code"}),"\n",(0,r.jsxs)(n.p,{children:["The version of the code used in this article can be found ",(0,r.jsx)(n.a,{href:"https://github.com/danielrive/smart-cash/releases/tag/v1.0.0",children:"here"}),". only specific sections of the code are included here to provide explanations, as this approach avoids the need to paste the entire code."]}),"\n",(0,r.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The image below shows the first version of the architecture to use, I chose Kubernetes for this project as it allows me to explore some tools for K8 and improve some skills to present a K8 certification."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/x1b6f3mgm9voy16u0lp8.jpeg",alt:"Diagram Arch v1"})}),"\n",(0,r.jsx)(n.h3,{id:"iac",children:"IaC"}),"\n",(0,r.jsx)(n.p,{children:"Terraform is the tool for IaC, while I won't delve into a detailed terraform code explanation, I will provide some key highlights:"}),"\n",(0,r.jsx)(n.h4,{id:"networking",children:"Networking"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.a,{href:"https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/latest",children:"third-party"})," TF module is used. to save some aws costs the NAT gateways have been disabled."]}),"\n",(0,r.jsx)(n.h4,{id:"eks",children:"EKS"}),"\n",(0,r.jsxs)(n.p,{children:["A TF module has been developed to deploy the resources needed for an EKS cluster. I created manually an IAM user and passed it as a variable(",(0,r.jsx)(n.em,{children:"var.userRoleARN"}),") to the EKS module. This internally runs an ",(0,r.jsx)(n.em,{children:"eksctl"})," command to add it to the RBAC configs. This user will be used to operate the cluster locally."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-Terraform",children:'resource "null_resource" "iam-role-cluster-access" {\n  provisioner "local-exec" {\n    command = <<EOF\n      curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp\n      /tmp/eksctl version\n      /tmp/eksctl create iamidentitymapping --cluster ${local.eksClusterName} --region=${var.region} --arn ${var.userRoleARN} --group system:masters --username "AWSAdministratorAccess:{{SessionName}}"\n    EOF\n  }\n  depends_on = [\n    aws_eks_cluster.kube_cluster,\n    aws_eks_node_group.worker-node-group\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"EKS worker nodes will run in public subnets, this is because I have disabled the NAT GW to save some costs."}),"\n",(0,r.jsx)(n.h2,{id:"infrastructure-pipeline",children:"Infrastructure Pipeline"}),"\n",(0,r.jsx)(n.h3,{id:"branch-strategy",children:"Branch strategy"}),"\n",(0,r.jsx)(n.p,{children:"I will follow a common branch strategy as the following image shows. The main branch is associated with the production environment."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dxc1vvelqq1l5jjqut7d.png",alt:"Branch-Strategy"})}),"\n",(0,r.jsx)(n.h3,{id:"github-actions",children:"GitHub Actions"}),"\n",(0,r.jsxs)(n.p,{children:["GitHub actions will be used to implement the pipeline to deploy the infrastructure in AWS, if you are not familiar with GitHub actions terminology you can check the ",(0,r.jsx)(n.a,{href:"https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions",children:"documentation"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["You can find the YAML files in the ",(0,r.jsx)(n.em,{children:".github"})," folder, which also contains other 3 subfolders, let's explore them in detail."]}),"\n",(0,r.jsx)(n.h4,{id:"actions-folder",children:"actions folder"}),"\n",(0,r.jsxs)(n.p,{children:["This folder contains the ",(0,r.jsx)(n.a,{href:"https://docs.github.com/en/actions/creating-actions/creating-a-composite-action",children:"GitHub composite Actions"})," to use in the workflows, you can think of an action as a template that defines the task to execute(jobs). Now let's review the ",(0,r.jsx)(n.em,{children:"terraform-plan"})," action."]}),"\n",(0,r.jsx)(n.p,{children:"The first part defines the name and the inputs for the action, in this case, I am just defining the working directory where TF is placed as an input."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-Yaml",children:"name: 'Terraform Plan'\ndescription: 'Running Terraform plan'\n\ninputs:\n  WORKING_DIRECTORY:\n    description: 'directory where the tf code is'\n    required: false\n    default: '/infra/terraform'\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"The second part defines the tasks to execute, this action will start installing Terraform."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-YAML",children:"runs:\n  using: \"composite\"\n  steps:\n      - name: Terraform install\n        id: 'install-terraform'\n        uses: hashicorp/setup-terraform@v2\n        with: \n         terraform_version: '${{ env.TERRAFORM_VERSION }}'\n      - name: Validate terraform version\n        id: validate-tf-version\n        run: terraform version\n        shell: bash\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Notice that the step ",(0,r.jsx)(n.em,{children:"Terraform install"})," is using an external GH action, ",(0,r.jsx)(n.a,{href:"https://github.com/marketplace/actions/hashicorp-setup-terraform",children:"hashicorp/setup-terraform@v2"}),", the version of this action is specified after the @. This action is available in the ",(0,r.jsx)(n.a,{href:"https://github.com/marketplace?type=actions",children:"GH actions marketplace"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The next step is to run terraform init but I won't delve into detail, therefore, let's proceed to the final two steps."}),"\n",(0,r.jsxs)(n.p,{children:["The step ",(0,r.jsx)(n.em,{children:"Run terraform plan"})," runs the TF plan command passing some variables that are defined in the workflow definition, the plan generated is saved in a file named with the GH actions run id."]}),"\n",(0,r.jsx)(n.p,{children:"Finally, the plan generated in the previous step is published as an artifact, that is used for the action created for the TF apply process."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-YAML",children:"      - name: Run terraform plan\n        id: terraform-plan\n        run: | \n            terraform plan \\\n            -input=false \\\n            -var 'region=${{ env.AWS_REGION }}' \\\n            -var 'environment=${{ env.ENVIRONMENT }}' \\\n            -var 'project_name=${{ env.PROJECT_NAME }}' \\\n            -out ${{ github.run_id }}.tfplan\n        shell: bash\n        working-directory: '.${{ inputs.WORKING_DIRECTORY }}'\n\n      - name: Publish Artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: tf-plan\n          path: '${{ github.workspace }}${{ inputs.WORKING_DIRECTORY }}/${{ github.run_id }}.tfplan'\n\n"})}),"\n",(0,r.jsx)(n.h4,{id:"jobs",children:"jobs"}),"\n",(0,r.jsx)(n.p,{children:"This folder stores some bash scripts used in the pipelines to perform specific tasks, currently just one script is stored here, and its purpose is to create the S3 bucket and the DynamoDB tables used for the TF state."}),"\n",(0,r.jsx)(n.p,{children:"The script runs some AWS CLI commands to validate if the S3 bucket and DynamoDB table exist, if not the resources are created."}),"\n",(0,r.jsx)(n.p,{children:"A composite action has been created to execute this script, you can find it with the name terraform-backend."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-YAML",children:"name: 'Terraform backend set-up'\ndescription: 'set-up terraform plan'\nruns:\n  using: \"composite\"\n  steps:\n    - name: Config tf backend\n      id: tf-backend\n      run: ./terraform-backend.sh\n      shell: bash\n      working-directory: .github/workflows\n"})}),"\n",(0,r.jsx)(n.h4,{id:"workflows",children:"Workflows"}),"\n",(0,r.jsx)(n.p,{children:"Workflows define the triggers(commits, tags, branches...) for the pipeline and also specify the process to execute(jobs), inside the workflow you can use the composite actions already defined."}),"\n",(0,r.jsx)(n.h5,{id:"workflow-template",children:"Workflow Template"}),"\n",(0,r.jsx)(n.p,{children:"I have created a workflow template that defines the common tasks for all the environments, but this does not define the triggers. let's take a look at the template."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-Yaml",children:"name: terraform deploy template\non:\n  workflow_call:\n    inputs:\n      AWS_REGION:\n        description: 'aws region where the resources will be deployed'\n        required: true\n        type: string\n     secrets: \n      AWS_ACCOUNT_NUMBER:\n        required: true\n"})}),"\n",(0,r.jsx)(n.p,{children:"The initial section defines the inputs and secrets for the workflow, the main difference between inputs and secrets is that Github hides the value of the secret in the workflow logs."}),"\n",(0,r.jsx)(n.p,{children:"The second part of the template defines some common environment variables."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"env:\n  ENVIRONMENT: ${{ inputs.ENVIRONMENT }}\n  AWS_REGION: ${{ inputs.AWS_REGION }}\n  PROJECT_NAME: ${{ inputs.PROJECT_NAME }}\n  TERRAFORM_VERSION: ${{ inputs.TERRAFORM_VERSION }}\n  AWS_IAM_ROLE_GH: 'GitHubAction-AssumeRoleWithAction'\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can observe that the value for the env variable AWS_REGION is set to the value passed by the input inputs.AWS_REGION defined earlier. Why it is done? let's review one snippet of code from the composite action for the terraform plan to gain a better understanding."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"- name: Run terraform plan\n        id: terraform-plan\n        run: | \n            terraform plan \\\n            -input=false \\\n            -var 'project_name=${{ env.PROJECT_NAME }}' \\\n"})}),"\n",(0,r.jsx)(n.p,{children:"As you can see I'm using the env variable PROJECT_NAME and passing it as a TF variable, this is possible because in the workflow I defined the value for the variable, and this is passed down in the runner. You can use inputs here but you would need to define the same input in the composite action."}),"\n",(0,r.jsx)(n.p,{children:"The last part of the template defines the jobs to execute"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"\njobs:\n## Execute bash script that  create s3 bucket and dynamodb table for Terraform backend\n  set-up-terraform-backend:\n    runs-on: ubuntu-latest\n    steps:  \n      - name: checkout-repo\n        uses: actions/checkout@v4\n      - name: configure aws credentials\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          role-to-assume: 'arn:aws:iam::${{ secrets.AWS_ACCOUNT_NUMBER }}:role/${{ env.AWS_IAM_ROLE_GH }}' \n          role-session-name: GitHub_to_AWS_via_FederatedOIDC\n          aws-region: ${{ env.AWS_REGION }}\n      - name: config tf backend\n        id: tf-backend\n        run: ./terraform-backend.sh\n        working-directory: .github/jobs/\n"})}),"\n",(0,r.jsx)(n.p,{children:"The provided code shows the job to set up the Terraform backend, this job is executed in a Ubuntu runner that is defined by runs-on."}),"\n",(0,r.jsx)(n.p,{children:"Let's check the steps executed for the job."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The first step is to make a checkout of the repo into the runner, this is done by an ",(0,r.jsx)(n.a,{href:"https://github.com/marketplace/actions/checkout",children:"external composite action"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["To execute Terraform the job needs access to AWS, this is done by an ",(0,r.jsx)(n.a,{href:"https://github.com/marketplace/actions/configure-aws-credentials-action-for-github-actions",children:"external composite action"}),", to avoid pass Access and Secret keys OpenID Connect (OIDC) will be used, which allows GitHub Actions workflows to access AWS. You need to create an IAM IdP in your AWS account and associate it with an IAM role, this role must contain the permissions that Terraform needs to run properly.\nThe details for the configuration can be checked ",(0,r.jsx)(n.a,{href:"https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services",children:"here"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Once the AWS credentials have been configured you can call the composite action created to set up the Teraform backend."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The other jobs follow a similar pattern but they execute the composite actions for the Terraform plan and apply."}),"\n",(0,r.jsx)(n.h5,{id:"using-the-template",children:"Using the template"}),"\n",(0,r.jsx)(n.p,{children:"Once the template is ready you can create the workflows for each environment. let's review the workflow for the develop environment."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"name: Terraform infra workflow DEVELOP\nrun-name: terraform-deploy-DEVELOP\n\non: \n  push:\n    branches:\n      - develop\n    paths:\n      - \"infra/**\"\n  pull_request:\n    branches:\n      - develop\n\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n\ndefaults:\n  run:\n    shell: bash\n    working-directory: ./infra/terraform\n\njobs:\n  ### Makes a call to the workflow template defined to execute terraform, in this case, the variables define the develop environment\n  terraform-deploy:\n    uses: danielrive/smart-cash/.github/workflows/run-terraform-template.yaml@develop\n    with: \n      AWS_REGION: 'us-west-2'\n      ENVIRONMENT: 'develop'\n      PROJECT_NAME: 'smart-cash'\n      TERRAFORM_VERSION: '1.4.6'\n    secrets:\n      AWS_ACCOUNT_NUMBER: ${{ secrets.AWS_ACCOUNT_NUMBER_DEVELOP }}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["I have defined two triggers for the workflow, The first trigger is when new updates are pushed to ",(0,r.jsx)(n.em,{children:"infra"})," folder within the develop branch, and the second trigger is when a new Pull request is open with the develop branch as a base."]}),"\n",(0,r.jsx)(n.p,{children:"The permissions section is necessary to generate a token used to establish the connection with AWS IAM IdP."}),"\n",(0,r.jsx)(n.p,{children:"In the job definition, you can is where you can utilize the previously created template, you need to specify the path where the template is located and the values for the inputs defined in the template."}),"\n",(0,r.jsx)(n.p,{children:"You can create other workflows for other environments and pass the respective values for inputs."}),"\n",(0,r.jsx)(n.p,{children:"Up to this point, you've covered the first phase of this project. In the upcoming articles, you'll delve into the implementation of various other tools and continue building the project."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},9913:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/gh-actions-3531739acdde0650318b603c71dbeb2d.jpg"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);