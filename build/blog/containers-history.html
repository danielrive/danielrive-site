<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">Containers - entre historia y runtimes | Daniel Rivera</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://danielrive-site.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://danielrive-site.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://danielrive-site.github.io/blog/containers-history"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Containers - entre historia y runtimes | Daniel Rivera"><meta data-rh="true" name="description" content="containers-crazy"><meta data-rh="true" property="og:description" content="containers-crazy"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-03-26T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/danielrive"><meta data-rh="true" property="article:tag" content="Kubernetes"><link data-rh="true" rel="icon" href="/img/cloud-icon1-554344964.png"><link data-rh="true" rel="canonical" href="https://danielrive-site.github.io/blog/containers-history"><link data-rh="true" rel="alternate" href="https://danielrive-site.github.io/blog/containers-history" hreflang="en"><link data-rh="true" rel="alternate" href="https://danielrive-site.github.io/blog/containers-history" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://danielrive-site.github.io/blog/containers-history","mainEntityOfPage":"https://danielrive-site.github.io/blog/containers-history","url":"https://danielrive-site.github.io/blog/containers-history","headline":"Containers - entre historia y runtimes","name":"Containers - entre historia y runtimes","description":"containers-crazy","datePublished":"2023-03-26T00:00:00.000Z","author":{"@type":"Person","name":"Daniel German Rivera","description":"Cloud Engineer","url":"https://github.com/danielrive"},"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://danielrive-site.github.io/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Daniel Rivera RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Daniel Rivera Atom Feed"><link rel="stylesheet" href="/assets/css/styles.ce37c9a8.css">
<script src="/assets/js/runtime~main.51e5b695.js" defer="defer"></script>
<script src="/assets/js/main.2fe43743.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">Daniel Rivera</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/danielrive" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2024</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/eks-fluentbit">Configuring Logging in AWS EKS Using Fluent Bit and CloudWatch</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/terraform-gitops">Using Terraform to push files to Git Repo for GitOps</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2023</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/EKS-Prometheus">Adding monitoring to EKS using Prometheus operator</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/fluxcd">GitOps with FluxCD</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/github-actions">AWS Infrastructure Terraform and GitHub Actions</a></li></ul></div></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">Containers - entre historia y runtimes</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-03-26T00:00:00.000Z">March 26, 2023</time> · <!-- -->9 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="/blog/authors/danielrivera"><span class="authorName_yefp">Daniel German Rivera</span></a></div><small class="authorTitle_nd0D" title="Cloud Engineer">Cloud Engineer</small><div class="authorSocials_rSDt"><a href="https://github.com/danielrive" target="_blank" rel="noopener noreferrer" class="authorSocialLink_owbf" title="GitHub"><svg viewBox="0 0 256 250" width="1em" height="1em" class="authorSocialLink_owbf githubSvg_Uu4N" xmlns="http://www.w3.org/2000/svg" style="--dark:#000;--light:#fff" preserveAspectRatio="xMidYMid"><path d="M128.001 0C57.317 0 0 57.307 0 128.001c0 56.554 36.676 104.535 87.535 121.46 6.397 1.185 8.746-2.777 8.746-6.158 0-3.052-.12-13.135-.174-23.83-35.61 7.742-43.124-15.103-43.124-15.103-5.823-14.795-14.213-18.73-14.213-18.73-11.613-7.944.876-7.78.876-7.78 12.853.902 19.621 13.19 19.621 13.19 11.417 19.568 29.945 13.911 37.249 10.64 1.149-8.272 4.466-13.92 8.127-17.116-28.431-3.236-58.318-14.212-58.318-63.258 0-13.975 5-25.394 13.188-34.358-1.329-3.224-5.71-16.242 1.24-33.874 0 0 10.749-3.44 35.21 13.121 10.21-2.836 21.16-4.258 32.038-4.307 10.878.049 21.837 1.47 32.066 4.307 24.431-16.56 35.165-13.12 35.165-13.12 6.967 17.63 2.584 30.65 1.255 33.873 8.207 8.964 13.173 20.383 13.173 34.358 0 49.163-29.944 59.988-58.447 63.157 4.591 3.972 8.682 11.762 8.682 23.704 0 17.126-.148 30.91-.148 35.126 0 3.407 2.304 7.398 8.792 6.14C219.37 232.5 256 184.537 256 128.002 256 57.307 198.691 0 128.001 0Zm-80.06 182.34c-.282.636-1.283.827-2.194.39-.929-.417-1.45-1.284-1.15-1.922.276-.655 1.279-.838 2.205-.399.93.418 1.46 1.293 1.139 1.931Zm6.296 5.618c-.61.566-1.804.303-2.614-.591-.837-.892-.994-2.086-.375-2.66.63-.566 1.787-.301 2.626.591.838.903 1 2.088.363 2.66Zm4.32 7.188c-.785.545-2.067.034-2.86-1.104-.784-1.138-.784-2.503.017-3.05.795-.547 2.058-.055 2.861 1.075.782 1.157.782 2.522-.019 3.08Zm7.304 8.325c-.701.774-2.196.566-3.29-.49-1.119-1.032-1.43-2.496-.726-3.27.71-.776 2.213-.558 3.315.49 1.11 1.03 1.45 2.505.701 3.27Zm9.442 2.81c-.31 1.003-1.75 1.459-3.199 1.033-1.448-.439-2.395-1.613-2.103-2.626.301-1.01 1.747-1.484 3.207-1.028 1.446.436 2.396 1.602 2.095 2.622Zm10.744 1.193c.036 1.055-1.193 1.93-2.715 1.95-1.53.034-2.769-.82-2.786-1.86 0-1.065 1.202-1.932 2.733-1.958 1.522-.03 2.768.818 2.768 1.868Zm10.555-.405c.182 1.03-.875 2.088-2.387 2.37-1.485.271-2.861-.365-3.05-1.386-.184-1.056.893-2.114 2.376-2.387 1.514-.263 2.868.356 3.061 1.403Z"></path></svg></a><a href="https://www.linkedin.com/in/danielrive/" target="_blank" rel="noopener noreferrer" class="authorSocialLink_owbf" title="LinkedIn"><svg width="1em" height="1em" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid" viewBox="0 0 256 256" class="authorSocialLink_owbf"><path d="M218.123 218.127h-37.931v-59.403c0-14.165-.253-32.4-19.728-32.4-19.756 0-22.779 15.434-22.779 31.369v60.43h-37.93V95.967h36.413v16.694h.51a39.907 39.907 0 0 1 35.928-19.733c38.445 0 45.533 25.288 45.533 58.186l-.016 67.013ZM56.955 79.27c-12.157.002-22.014-9.852-22.016-22.009-.002-12.157 9.851-22.014 22.008-22.016 12.157-.003 22.014 9.851 22.016 22.008A22.013 22.013 0 0 1 56.955 79.27m18.966 138.858H37.95V95.967h37.97v122.16ZM237.033.018H18.89C8.58-.098.125 8.161-.001 18.471v219.053c.122 10.315 8.576 18.582 18.89 18.474h218.144c10.336.128 18.823-8.139 18.966-18.474V18.454c-.147-10.33-8.635-18.588-18.966-18.453" fill="#0A66C2"></path></svg></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p><img decoding="async" loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/sox1n5tbcssth6p8eayl.png" alt="containers-crazy" class="img_ev3q"></p>
<p>Estudiando kubernetes gasté un tiempo considerable intentando entender muchos conceptos, por ejemplo, por todo lado se habla de <em>OCI compliant</em>, buscas <em>OCI</em> y te lleva a <em>runtime-spec</em>, buscas <em>runtimes</em> y te lleva a <em>containerd</em>, <em>runc</em>, <em>image-spec</em>, <em>cgroups</em>, <em>namespaces</em>, etc; puedes pasar días buscando, y mucho más cuando eres del tipo de persona que quiere entender a fondo cómo funcionan las cosas.</p>
<p>Motivado por lo anterior, me decidí a escribir este post con la idea de compartir los conceptos que logré adquirir y que me han servido para entender varias cosas del gran mundo de los containers, en algunas cosas no voy a tan bajo nivel ya que hay muchos conceptos que todavía desconozco y puedo decir cosas equiviocadas.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="lo-básico">Lo básico<a href="#lo-básico" class="hash-link" aria-label="Direct link to Lo básico" title="Direct link to Lo básico">​</a></h2>
<p>Iniciemos entendiendo un poco la idea detrás de los containers.</p>
<p>Containers tienen como objetivo crear un ambiente virtual <strong><em>aislado</em></strong> el cual se pueda distribuir y desplegar fácilmente. Dentro del container pueden correr diferentes procesos los cuales deben estar aislados de otros corriendo en el host. El kernel de linux ofrece distintas funcionalidades que permiten la creación de estos ambientes. Hay dos componentes principales que quizás son el core de todos los containers.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="linux-namespaces">Linux namespaces<a href="#linux-namespaces" class="hash-link" aria-label="Direct link to Linux namespaces" title="Direct link to Linux namespaces">​</a></h3>
<p>Linux namespaces nos permite crear ambientes virtuales y aislados, estos particionan recursos del kernel y hacen que  sean visibles solo para los procesos que corren dentro del namespace, pero no para procesos externos. En otras palabras, namespaces nos facilitan el aislamiento entre procesos.</p>
<p>¿Qué recursos se pueden particionar?, bueno esto va a depender del <a href="https://www.redhat.com/sysadmin/7-linux-namespaces" target="_blank" rel="noopener noreferrer">tipo de namespace</a> que se este usando, por ejemplo, network namespaces nos permite encapsular los recursos relacionados con networking, como interfaces, tablas de rutas, etc. De esta forma podemos crear una red virtual dentro de nuestro namespace.</p>
<p>Este <a href="https://www.redhat.com/sysadmin/7-linux-namespaces" target="_blank" rel="noopener noreferrer">post</a> explica un poco más en detalle los namespaces.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="cgroups">cgroups<a href="#cgroups" class="hash-link" aria-label="Direct link to cgroups" title="Direct link to cgroups">​</a></h3>
<p>Recordemos que el Kernel de Linux es la interfaz principal entre el hardware y los procesos, permitiendo la comunicación entre estos dos y ayudando a la gestión de recursos, por ejemplo, puede terminar procesos que consuman demasiada memoria para evitar afectar el sistema operativo. Adicionalmente pueden controlar qué procesos pueden consumir cierta cantidad de recursos.</p>
<p>cgroups es una funcionalidad del Kernel de Linux que permite organizar jerárquicamente procesos y distribuir recursos(cpu, memoria, networking, storage) dentro de dicha jerarquía.</p>
<p>Configurar cgroups puede ser un poco complejo, en mi caso estuve leyendo varios post acerca del tema y requiere cierto tiempo para entender por completo su funcionamiento. En esta <a href="https://www.redhat.com/sysadmin/cgroups-part-one" target="_blank" rel="noopener noreferrer">serie de posts</a> creados por RedHat se habla sobe cgroups y su configuración a través de systemd, pero si se desea entrar en detalle la <a href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/cgroups.html" target="_blank" rel="noopener noreferrer">documentación de Linux</a> puede ser de ayuda.</p>
<p>cgroups y namespaces se convierten en los ingredientes secretos en la creación de containers, namespaces permiten aislamiento a nivel de recursos y cgroups permiten controlar los limites para dichos recursos.</p>
<p>Por suerte hoy en día con una sola linea podemos crear un container, no tenemos que entrar a configurar namespaces ni cgroups.</p>
<p>Veamos un poco de la evolución de los containers y así vamos aclarando ciertas cosas.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="un-poco-de-historia">Un poco de historia<a href="#un-poco-de-historia" class="hash-link" aria-label="Direct link to Un poco de historia" title="Direct link to Un poco de historia">​</a></h3>
<p>Docker fue el primero que popularizó los containers, era(o es) común asociar containers directamente con Docker, pero antes ya existía algo llamado LXC(Linux containers), el cual puede entenderse como un proveedor de ambientes virtuales en Linux que usa ciertos componentes del Kernel de Linux para crear ambientes aislados(containers).</p>
<p><img decoding="async" loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jquo7g5j5iusxgy42wv3.png" alt="Image lxc" class="img_ev3q"></p>
<p>LXC se encuentra dentro del user-space, es decir, nosotros interactuamos con LXC y este se encarga de interactuar con los componentes del kernel para permitir la creación de containers. Aqui un <a href="https://www.youtube.com/watch?v=aIwgPKkVj8s" target="_blank" rel="noopener noreferrer">video</a> en donde se puede ver LXC en acción.</p>
<blockquote>
<p><strong>Nota:</strong> Antes de LXC ya se habían desarrollado otros alternativas para la creación de containers como OpenVZ y Linux Vserver. LXC es mencionado inicialmente ya que es lo más cercano a Docker que es el software con el que muchos iniciamos interactuando con containers.</p>
</blockquote>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="la-llegada-de-docker">La llegada de Docker<a href="#la-llegada-de-docker" class="hash-link" aria-label="Direct link to La llegada de Docker" title="Direct link to La llegada de Docker">​</a></h4>
<p>Docker empaquetó LXC en una herramienta que facilitaba más la creación de containers. Al ganar popularidad se crearon mejoras y unos meses después Docker lanzó <a href="https://github.com/opencontainers/runc/tree/main/libcontainer" target="_blank" rel="noopener noreferrer">libcontainer</a> el cual está escrito en <a href="https://github.com/opencontainers/runc/tree/main/libcontainer" target="_blank" rel="noopener noreferrer">Golang</a> y básicamente reemplazaba LXC.</p>
<p><img decoding="async" loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ydjpgj8o2rmm15btbqet.png" alt="Docker libcontainer" class="img_ev3q"></p>
<p>Docker se enfocó más en la creación de containers optimizados para el despliegue de aplicaciones mejorando la portabilidad. Este <a href="https://earthly.dev/blog/lxc-vs-docker/" target="_blank" rel="noopener noreferrer">post</a> explica más detalladamente las diferencias entre LXC y Docker.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="definiendo-un-estándar-para-containers">Definiendo un estándar para containers<a href="#definiendo-un-estándar-para-containers" class="hash-link" aria-label="Direct link to Definiendo un estándar para containers" title="Direct link to Definiendo un estándar para containers">​</a></h4>
<p>Como alternativa a Docker, empezaron a surgir otras opciones,CoreOS por su parte lanzó <a href="https://www.redhat.com/en/topics/containers/what-is-rkt" target="_blank" rel="noopener noreferrer">rkt(2014)</a> proponiendo mejores de seguridad, CoreOS <a href="https://lwn.net/Articles/623875/" target="_blank" rel="noopener noreferrer">argumentaba</a> que Docker había sido construido como un monolito el cual corría como root en el host, abriendo posibilidades a comprometer todo el host en el caso de un ataque.</p>
<p>rkt usa <a href="https://github.com/appc" target="_blank" rel="noopener noreferrer">appc(open source container)</a> con el fin de mejorar la operabilidad, appc tiene como propósito crear un estándar general para crear containers buscando ser vendor-independent y OS-independent.</p>
<p>Otras iniciativas empezaron a surgir debido a la alta popularidad de los containers y debido a esto, en 2015 se crea <a href="https://opencontainers.org/about/overview/" target="_blank" rel="noopener noreferrer">OCI(Open Container Initiative)</a> para definir un estandar para containers(<a href="https://github.com/opencontainers/runtime-spec/blob/main/spec.md" target="_blank" rel="noopener noreferrer">runtimes</a> e <a href="https://github.com/opencontainers/image-spec/blob/main/spec.md" target="_blank" rel="noopener noreferrer">imagenes</a>).</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="oci-runtime-spec">OCI Runtime spec<a href="#oci-runtime-spec" class="hash-link" aria-label="Direct link to OCI Runtime spec" title="Direct link to OCI Runtime spec">​</a></h4>
<p><em>Runtime spec</em> define la configuración(archivo JSON), ambiente y ciclo de vida de un container. Las configuraciones son definidas en un archivo llamado config.json, el cual contiene la metadata necesaria para la ejecución del container, este archivo es definido de acuerdo a plataforma a usar(windows, linux, solaris, etc).</p>
<p>otro concepto a destacar es el <em>filesystem bundle</em>, este es un grupo de archivos con la data y metadata para correr un container. Los principales archivos que deben contener son, el config.json mencionado anteriormente y el <a href="https://www.baeldung.com/linux/rootfs" target="_blank" rel="noopener noreferrer">rootfs(linux file system)</a>, este  <em>filesystem bundle</em> se genera a través del container image.</p>
<p>Todas las especificaciones para el container runtime son descritas <a href="https://github.com/opencontainers/runtime-spec/blob/main/spec.md" target="_blank" rel="noopener noreferrer">aqui</a>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="oci-image-spec">OCI Image spec<a href="#oci-image-spec" class="hash-link" aria-label="Direct link to OCI Image spec" title="Direct link to OCI Image spec">​</a></h4>
<p>Docker en sus inicios ya había definido las especificaciones para la creación de imágenes<a href="https://docs.docker.com/registry/spec/manifest-v2-2/" target="_blank" rel="noopener noreferrer">Image Manifest 2 Schema Version 2</a>, al ser el más popular, OCI partió de este para crear un estándar más general, que no estuviera asociado a un vendor en específico. <em>Image spec</em> define como construir y empaquetar container images, personalmente no he entendido del todo el funcionamiento pero aquí está la url del <a href="https://github.com/opencontainers/image-spec" target="_blank" rel="noopener noreferrer">repo</a> y un <a href="https://blog.quarkslab.com/digging-into-the-oci-image-specification.html" target="_blank" rel="noopener noreferrer">blog-post</a> que contienen mayor información.</p>
<p>Haciendo uso del <em>Image spec</em>, se puede crear un container image que puede ser ejecutada por cualquier <em>OCI Runtime</em>, esto quiere decir que a través del <em>Image spec</em> se puede generar el <em>filesystem bundle</em>, el cual es usado por el runtime para la creación y ejecución del container.</p>
<blockquote>
<p>The Runtime Specification outlines how to run a &quot;filesystem bundle&quot; that is unpacked on disk. At a high-level an OCI implementation would download an OCI Image then unpack that image into an OCI Runtime filesystem bundle. At this point the OCI Runtime Bundle would be run by an OCI Runtime.</p>
</blockquote>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="container-runtimes-y-kubernetes">Container runtimes y Kubernetes<a href="#container-runtimes-y-kubernetes" class="hash-link" aria-label="Direct link to Container runtimes y Kubernetes" title="Direct link to Container runtimes y Kubernetes">​</a></h4>
<p>En el 2015 se lanza el primer release de kubernetes, el cual usaba Docker como runtime.</p>
<p>Docker decide dividir el monolito creado. libcontainer es donado a OCI y Docker empieza a trabajar en un proyecto llamado runC, este se puede ver como una herramienta que lee OCI specifications e interactúa con libcontainer para la creación de containers. runC es independiente del Docker Engine y es donado a OCI.</p>
<p>runC es una low-level runtime por lo que también se desarrolla <em>containerd</em> el cual es como una interfaz entre el cliente y runC.</p>
<p><img decoding="async" loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/zi3mkr4s6u5bbmj3y9ls.png" alt="docker-runc-containerd" title="fuente: https://images.techhive.com/images/article/2016/04/docker-runc-100656060-large.idge.png" class="img_ev3q"></p>
<p>Hasta el momento solo se ha cubierto parte del origen de los container y el origen de algunas herramientas que seguimos viendo hoy en día como runC y conteinerd. En lo que sigue del post trataré de exponer un poco más a fondo las <em>container images</em> al igual que algunas <em>containers runtimes</em>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="container-images">Container Images<a href="#container-images" class="hash-link" aria-label="Direct link to Container Images" title="Direct link to Container Images">​</a></h3>
<p>Antes de entrar a ver las <em>containers runtimes</em>, es importante entender qué es lo que contienen las <em>containers images</em>, para ello vamos a usar <a href="https://www.redhat.com/en/topics/containers/what-is-skopeo" target="_blank" rel="noopener noreferrer">Skopeo</a>.</p>
<p>Skopeo permite manipular e inspeccionar <em>container images</em> ya sea para Windows, Linux o MacOs. En este caso vamos a usar Skopeo para obtener &quot;el contenido&quot; de una imagen que se encuentra en DockerHub, esto es muy similar al comando <a href="https://docs.docker.com/engine/reference/commandline/export/" target="_blank" rel="noopener noreferrer">docker export</a>,pero en este caso no vamos a instalar Docker.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="copiando-images-con-skopeo">copiando images con skopeo<a href="#copiando-images-con-skopeo" class="hash-link" aria-label="Direct link to copiando images con skopeo" title="Direct link to copiando images con skopeo">​</a></h4>
<p>Para instalar skopeo se puede usar snap en ubuntu</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sudo snap install skopeo --edge</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>una vez que finalice la instalación podemos copiar una imagen que se encuentra en DockerHub a nuestro local. En este caso se va a usar la imagen de golang.</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sudo skopeo --insecure-policy copy docker://golang:latest  oci://home/ubuntu/example-dev-to/golang-image-v2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Skopeo copia el contenido de la imagen en el destino especificado, en este caso <code>oci:/home/ubuntu/example-dev-to/golang-image-v2</code>. En la imagen se puede ver que se tiene un archivo index.json, oci-layout y un directorio llamado blobs. Esto corresponde a la estructura de archivos definidos por <a href="https://github.com/opencontainers/image-spec/blob/main/spec.md" target="_blank" rel="noopener noreferrer">OCI</a></p>
<p><img decoding="async" loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/f76zraaa4bdgws82wr9f.png" alt="golang-copy-skopeo" class="img_ev3q"></p>
<p>el <em>index.json</em> se puede entender como un resumen de la imagen, en donde se ve el sistema operativo y la arquitectura, además se especifica la ubicación del <em>image manifest</em>.</p>
<p>El <em>image manifest</em> contiene metadata de la imagen al igual que las especificaciones de cada layer creada.</p>
<p>Revisando el index.json vamos a encontrar lo siguiente:</p>
<p><img decoding="async" loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wxaqowqg0vbmhjvsgvsq.png" alt="index.json golang image" class="img_ev3q"></p>
<p>Se puede ver información acerca del sistema operativo y arquitectura soportados por la imagen. El digest(linea 6) nos indica en que archivo se encuentra el manifest.json.</p>
<p><img decoding="async" loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7tyogxsh5q90vgolsvbu.png" alt="manifest" class="img_ev3q"></p>
<p>En el manifest(imagen anterior) se puede ver el digest para el config file y para cada una de las layers que se tienen. El <a href="https://github.com/opencontainers/image-spec/blob/main/media-types.md" target="_blank" rel="noopener noreferrer">mediaType</a> puede entenderse como el formato de cada archivo, por ejemplo la linea 4 nos dice que el archivo config de formato json se puede identificar con el digest <code>bdba673e96d6e9707e2a724103e8835dbdd11dc81ad0c76c4453066ed8db29fd</code>. Este se puede encontrar en la carpeta blobs y va a lucir como la siguiente imagen.</p>
<p><img decoding="async" loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/74dolefjcdzij0qhcf3d.png" alt="config.json" class="img_ev3q"></p>
<p>Este archivo ya contiene más información de la imagen, por ejemplo podemos ver el workdir y algunas variables de entorno.</p>
<p>pasemos ahora a las layers, en el manifest podemos identificar los digest para cada layers, si vemos el media type nos indica que es <code>v1.tar+gzip</code>, en este caso tenemos que descomprimir el contenido de dicho digest, para ello vamos a usar <code>tar</code></p>
<p><img decoding="async" loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/fd5iwfpygp71jutt0qcx.png" alt="unpackage-digest" class="img_ev3q"></p>
<p>Una vez termine el proceso podemos analizar el resultado, en este caso vamos a tener una serie de directorios que representan el rootfs de la imagen, estos archivos van a hacer parte de un layer en específico. Si observamos la siguente imagen podemos ver que tenemos /home, /etc y /bin, etc, los cuales representan el sistema de archivos de linux(rootfs).</p>
<p><img decoding="async" loading="lazy" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/clm54sgl7p2i08gtrd1b.png" alt="rootfs" class="img_ev3q"></p>
<p>Con esto vemos a alto nivel el contenido de un <em>container image</em>, al final el <em>container runtime</em> es el que se encarga de descomprimir y leer todos estos archivos, el cual va a ser usado para correr el container.</p>
<p>Hasta aquí va la primera parte de este post, en la siguiente veremos un poco m&#x27;as los container runtimes.</p></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a title="Content related with Kubernetes" class="tag_zVej tagRegular_sFm0" href="/blog/tags/kubernetes">Kubernetes</a></li></ul></div></div><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-03-26-Containers-entre-historia-runtimes.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/github-actions"><div class="pagination-nav__sublabel">Newer post</div><div class="pagination-nav__label">AWS Infrastructure Terraform and GitHub Actions</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/Log-Insights"><div class="pagination-nav__sublabel">Older post</div><div class="pagination-nav__label">Enabling logs and alerting in AWS EKS cluster - CloudWatch Log Insights and Metric filters</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#lo-básico" class="table-of-contents__link toc-highlight">Lo básico</a><ul><li><a href="#linux-namespaces" class="table-of-contents__link toc-highlight">Linux namespaces</a></li><li><a href="#cgroups" class="table-of-contents__link toc-highlight">cgroups</a></li><li><a href="#un-poco-de-historia" class="table-of-contents__link toc-highlight">Un poco de historia</a></li><li><a href="#container-images" class="table-of-contents__link toc-highlight">Container Images</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Docusaurus GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Daniel Rivera, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>